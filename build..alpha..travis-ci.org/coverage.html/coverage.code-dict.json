{"/home/travis/build/npmtest/node-npmtest-fireplace/test.js":"/* istanbul instrument in package npmtest_fireplace */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fireplace/lib.npmtest_fireplace.js":"/* istanbul instrument in package npmtest_fireplace */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_fireplace = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_fireplace = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-fireplace/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-fireplace && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_fireplace */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_fireplace\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_fireplace.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_fireplace.rollup.js'] =\n            local.assetsDict['/assets.npmtest_fireplace.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_fireplace.__dirname + '/lib.npmtest_fireplace.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/index.js":"/* jshint node: true */\n'use strict';\n\nmodule.exports = {\n  name: 'fireplace',\n  included: function(app) {\n    this._super.included(app);\n    this.app.import(app.bowerDirectory + '/firebase/firebase.js');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/store.js":"import Ember from 'ember';\n\nimport getOwner from 'ember-getowner-polyfill';\n\nimport EventQueue   from './support/event-queue';\nimport PromiseModel from './model/promise-model';\nimport MetaModel    from './model/meta-model';\n\nimport {\n  singularize\n} from 'ember-inflector';\n\nimport {\n  hasQueryOptions,\n  extractQueryOptions\n} from './utils/query';\n\nconst get         = Ember.get;\nconst guidFor     = Ember.guidFor;\nconst camelize    = Ember.String.camelize;\n\nexport default Ember.Service.extend({\n\n  firebaseRoot: null,\n\n  init() {\n    this._super();\n    this.clearCache();\n    this.queue = new EventQueue();\n  },\n\n  enqueueEvent(fn, context) {\n    this.queue.enqueue(fn, context);\n  },\n\n  // just returns a new instance of the same store with the same container\n  // means the cache is isolated & any finds etc are operating\n  // independently of the forked store.\n  // no need to re-join, just save or discard your changes & firebase\n  // takes care of keeping the other models in sync\n  fork() {\n    const factory = getOwner(this)._lookupFactory(\"service:store\");\n    return factory.create({\n      firebaseRoot: get(this, \"firebaseRoot\")\n    });\n  },\n\n  buildFirebaseRootReference(){\n    const url = get(this, 'firebaseRoot');\n    Ember.assert(\"Your store needs a firebaseRoot\", !!url);\n    if (url instanceof window.Firebase) {\n      return url;\n    }\n    return new window.Firebase(url);\n  },\n\n  createRecord(type, attributes) {\n    attributes = attributes || {};\n    const record = this.buildRecord(type, attributes.id, attributes);\n    this.storeInCache(type, record);\n    return record;\n  },\n\n  saveCollection(collection) {\n    const json  = collection.toFirebaseJSON();\n    const ref   = collection.buildFirebaseReference();\n\n    const limit = collection.get(\"limit\");\n    const start = collection.get(\"startAt\");\n    const end   = collection.get(\"endAt\");\n\n    // if the collection is built from a query as you'll nuke any data not matched\n    Ember.assert(\"Saving a collection which is the result of a query could lose data\", !limit && !start && !end);\n\n    return new Ember.RSVP.Promise((resolve, reject) => {\n      const callback = error => {\n        this.enqueueEvent(() => {\n          if (error) {\n            reject(error);\n          } else {\n            collection.listenToFirebase();\n            resolve(collection);\n          }\n        });\n      };\n      ref.set(json, callback);\n    }, \"FP: Save Collection \"+ref.toString());\n  },\n\n  saveRecord(record, attr) {\n    const ref      = record.buildFirebaseReference();\n    const priority = get(record, 'priority');\n    const json     = record.toFirebaseJSON();\n\n    record.trigger(\"save\");\n\n    return new Ember.RSVP.Promise((resolve, reject) => {\n      const callback = (error) => {\n        this.enqueueEvent(() => {\n          if (error) {\n            reject(error);\n          } else if (get(record, \"isDeleted\") || get(record, \"isDeleting\")) { // it was deleted in the time it took to save\n            reject(\"the record has since been deleted\");\n          } else {\n            if (!attr) {\n              this.storeInCache(record.constructor, record);\n            }\n            record.listenToFirebase();\n            resolve(record);\n            record.trigger(\"saved\");\n          }\n        });\n      };\n\n      if (attr) {\n        if (attr !== 'priority') {\n          const key = record.attributeKeyFromName(attr) || record.relationshipKeyFromName(attr);\n\n          Ember.assert(Ember.inspect(record) +\" has no attribute \"+ attr, !!key);\n\n          const value = json[key];\n          if (value) {\n            ref.child(key).set(value, callback);\n          } else {\n            ref.child(key).remove(callback);\n          }\n        } else {\n          ref.setPriority(priority, callback);\n        }\n      } else {\n        if (priority) {\n          ref.setWithPriority(json, priority, callback);\n        } else {\n          ref.set(json, callback);\n        }\n      }\n    }, \"FP: Save \"+ref.toString());\n  },\n\n  deleteRecord(record) {\n    const ref         = record.buildFirebaseReference();\n    const isListening = get(record, \"isListeningToFirebase\");\n\n    record.trigger(\"delete\");\n\n    if (isListening) {\n      record.stopListeningToFirebase();\n    }\n\n    return new Ember.RSVP.Promise((resolve, reject) => {\n      ref.remove(error => {\n        this.enqueueEvent(() => {\n          if (error) {\n            if (isListening) { // the delete failed, start listening to changes again\n              record.listenToFirebase();\n            }\n            reject(error);\n          } else {\n            resolve(record);\n            record.trigger(\"deleted\");\n          }\n        });\n      });\n    }, \"FP: Delete \"+ref.toString());\n  },\n\n  find(type, idOrQuery, options) {\n    if (arguments.length === 1) {\n      return this.findAll(type);\n    } else if (typeof idOrQuery === 'object') {\n      return this.findQuery(type, idOrQuery, options);\n    } else {\n      return this.findOne(type, idOrQuery, options);\n    }\n  },\n\n  fetch(type, idOrQuery, options) {\n    if (arguments.length === 1) {\n      return this.fetchAll(type);\n    } else if (typeof idOrQuery === 'object') {\n      return this.fetchQuery(type, idOrQuery, options);\n    } else {\n      return this.fetchOne(type, idOrQuery, options);\n    }\n  },\n\n  findOne(type, id, query) {\n    return this.findFetchOne(type, id, query, false);\n  },\n\n  fetchOne(type, id, query) {\n    return this.findFetchOne(type, id, query, true);\n  },\n\n  findQuery(type, query, options) {\n    return this.findFetchQuery(type, query, options, false);\n  },\n\n  fetchQuery(type, query, options) {\n    return this.findFetchQuery(type, query, options, true);\n  },\n\n  findAll(type, query) {\n    return this.findFetchQuery(type, query, {}, false);\n  },\n\n  fetchAll(type, query) {\n    return this.findFetchQuery(type, query, {}, true);\n  },\n\n  findFetchQuery(type, query, options, returnPromise) {\n    query   = query || {};\n    options = options || {};\n\n    // switch order if query is the options\n    if (hasQueryOptions(query) || query.path || query.collection) {\n      options = query;\n      query   = {};\n    }\n\n    const model = this.modelFor(type);\n\n    let reference;\n    if (options.path) {\n      reference = model.buildFirebaseRootReference(this).child(options.path);\n    } else {\n      reference = model.buildFirebaseReference(this, query);\n    }\n\n    return this.findFetchCollectionByReference(model, reference, query, options, returnPromise);\n  },\n\n  findFetchOne(type, id, query, returnPromise) {\n    query = query || {};\n\n    const placeholder = this.buildRecord(type, id, query);\n    const ref         = placeholder.buildFirebaseReference();\n    const existing    = this.findInCacheByReference(type, ref);\n\n    let promise;\n\n    if (existing) {\n      existing.listenToFirebase();\n      promise = Ember.RSVP.resolve(existing);\n      return returnPromise ? promise : PromiseModel.create({ promise, content: existing });\n    }\n\n    promise = new Ember.RSVP.Promise((resolve, reject) => {\n      ref.once('value', (snapshot) => {\n        this.enqueueEvent(() => {\n          const value = snapshot.val();\n          if (value) {\n\n            // for polymorhism\n            const modelType = this.modelFor(type).typeFromSnapshot(snapshot);\n            const record = this.createRecord(modelType, Ember.merge(query, { id, snapshot }));\n\n            record.listenToFirebase();\n            resolve(record);\n          } else {\n            reject('not found');\n          }\n        });\n      }, () => {\n        reject('permission denied');\n      });\n    }, \"FP: Find one \"+ref.toString());\n\n    return returnPromise ? promise : PromiseModel.create({ promise, content: placeholder });\n  },\n\n  findFetchCollectionByReference(model, ref, query, options, returnPromise) {\n    const type      = options.collection || \"object\";\n    const factory   = getOwner(this)._lookupFactory(\"collection:\"+type);\n\n    const collection = factory.create(Ember.$.extend({\n      store: this,\n      model: model,\n      query: query,\n      firebaseReference: ref\n    }, extractQueryOptions(options)));\n\n    if (returnPromise) {\n      return collection.fetch();\n    } else {\n      collection.listenToFirebase();\n      return collection;\n    }\n  },\n\n  modelFor(type) {\n    if (typeof type !== 'string') {\n      return type;\n    }\n\n    const container = getOwner(this);\n\n    const factory = container._lookupFactory('model:' + type);\n    Ember.assert(\"No model was found for '\" + type + \"'\", !!factory);\n    factory.typeKey = factory.typeKey || this._normalizeTypeKey(type);\n    return factory;\n  },\n\n  buildRecord(type, id, attributes) {\n    const factory = this.modelFor(type);\n    const record = factory.create({\n      store: this\n    });\n\n    if (attributes) {\n      record.setProperties(attributes);\n    }\n\n    if (id) {\n      record.set(\"id\", id);\n    }\n\n    return record;\n  },\n\n  clearCache() {\n    this.cache = {};\n  },\n\n  cacheForType(type) {\n    const model    = this.modelFor(type);\n    const guid     = guidFor(model);\n    const existing = this.cache[guid];\n\n    if (existing) {\n      return existing;\n    }\n\n    const cache = {\n      records: {}\n    };\n\n    this.cache[guid] = cache;\n\n    return cache;\n  },\n\n  storeInCache(type, record) {\n    // don't bother caching meta models for now\n    if (record instanceof MetaModel) {\n      return;\n    }\n\n    const cache = this.cacheForType(type);\n    const ref   = record.buildFirebaseReference().toString();\n\n    cache.records[ref] = record;\n  },\n\n  // when record is destroyed, remove it from the cache etc...\n  teardownRecord(record) {\n    const cache = this.cacheForType(record.constructor.typeKey);\n    const ref   = record.buildFirebaseReference().toString();\n\n    delete cache.records[ref];\n  },\n\n  findInCacheByReference(type, reference) {\n    const cache = this.cacheForType(type);\n    return cache.records[reference.toString()];\n  },\n\n  findInCacheOrCreateRecord(type, reference, attributes) {\n    const record = this.findInCacheByReference(type, reference);\n    if (record) {\n      return record;\n    } else {\n      attributes.id = reference.key();\n      return this.createRecord(type, attributes);\n    }\n  },\n\n  all(type) {\n    const cache   = this.cacheForType(type);\n    const records = cache.records;\n    const all     = Ember.A();\n\n    for (let reference in records) {\n      all.push(records[reference]);\n    }\n\n    return all;\n  },\n\n  _normalizeTypeKey(type) {\n    return camelize(singularize(type));\n  }\n\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/version.js":"export default '0.4.0';","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/config/ember-try.js":"/*jshint node:true*/\nmodule.exports = {\n  scenarios: [\n    {\n      name: 'default',\n      dependencies: { }\n    },\n    {\n      name: 'ember-1.12',\n      dependencies: {\n        'ember': '1.12'\n      }\n    },\n    {\n      name: 'ember-1.13',\n      dependencies: {\n        'ember': '1.13'\n      }\n    },\n    {\n      name: 'ember-release',\n      dependencies: {\n        'ember': 'components/ember#release'\n      },\n      resolutions: {\n        'ember': 'release'\n      }\n    },\n    {\n      name: 'ember-beta',\n      dependencies: {\n        'ember': 'components/ember#beta'\n      },\n      resolutions: {\n        'ember': 'beta'\n      }\n    },\n    {\n      name: 'ember-canary',\n      dependencies: {\n        'ember': 'components/ember#canary'\n      },\n      resolutions: {\n        'ember': 'canary'\n      }\n    }\n  ]\n};\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/config/environment.js":"/*jshint node:true*/\n'use strict';\n\nmodule.exports = function(/* environment, appConfig */) {\n  return { };\n};\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/collections/base.js":"import Ember from 'ember';\n\nimport LiveMixin from '../model/live-mixin';\n\nconst get           = Ember.get;\nconst set           = Ember.set;\nconst getProperties = Ember.getProperties;\n\nexport const QUERY_OPTIONS = [\n  'equalTo',\n  'limit',\n  'limitToFirst',\n  'limitToLast',\n  'orderByChild',\n  'orderByKey',\n  'orderByPriority',\n  'orderByValue',\n  'startAt',\n  'endAt'\n];\n\nexport default Ember.ArrayProxy.extend(LiveMixin, {\n  firebaseEvents: ['child_added', 'child_removed', 'child_moved'],\n\n  model:     null,\n  parent:    null,\n  parentKey: null,\n  snapshot:  null,\n  query:     null,\n\n  // filtering\n  equalTo:         null, // value, or {value, key}\n  limit:           null, // limit\n  limitToFirst:    null, // limit\n  limitToLast:     null, // limit\n  orderByChild:    null, // key\n  orderByKey:      null, // true\n  orderByPriority: null, // true\n  orderByValue:    null, // true\n  startAt:         null, // value, or {value, key}\n  endAt:           null, // value, or {value, key}\n\n  onFirebaseChildAdded:   null,\n  onFirebaseChildRemoved: null,\n  onFirebaseChildMoved:   null,\n  toFirebaseJSON:         null,\n\n  isNew: Ember.computed(\"snapshot\", function(){\n    return !get(this, \"snapshot\");\n  }),\n\n  firebaseReference: null,\n\n  debugReference: Ember.computed(function(){\n    return this.buildFirebaseReference().toString();\n  }),\n\n  buildFirebaseReference() {\n    // do we have an explicit reference?\n    const ref = get(this, 'firebaseReference');\n    if (ref) {\n      return ref;\n    }\n\n    // do we have an explicit path to build from?\n    const path  = get(this, 'firebasePath');\n    const store = get(this, 'store');\n\n    if (path) {\n      const rootRef = store.buildFirebaseRootReference();\n      return rootRef.child(path);\n    }\n\n    // are we an embedded collection in a relationship?\n    const parent    = get(this, 'parent');\n    const parentKey = get(this, 'parentKey');\n\n    if (parent && parentKey) {\n      const childKey = parent.relationshipKeyFromName(parentKey);\n      return parent.buildFirebaseReference().child(childKey);\n    }\n\n    // otherwise we're a root collection, use the model reference\n    const modelName  = get(this, 'model');\n    const modelClass = store.modelFor(modelName);\n\n    return modelClass.buildFirebaseReference(store);\n  },\n\n  buildFirebaseQuery() {\n    let reference = this.buildFirebaseReference();\n    const options = getProperties(this, QUERY_OPTIONS);\n\n    Ember.assert(\"you can only order by one thing at a time\", [options.orderByChild, options.orderByKey, options.orderByPriority, options.orderByValue].filter(o => o).length <= 1);\n\n    // Ordering has to come first\n\n    if (options.orderByChild) {\n      reference = reference.orderByChild(options.orderByChild);\n    }\n\n    if (options.orderByKey) {\n      reference = reference.orderByKey();\n    }\n\n    if (options.orderByValue) {\n      reference = reference.orderByValue();\n    }\n\n    if (options.orderByPriority) {\n      reference = reference.orderByPriority();\n    }\n\n    // Now we've ordered, we can filter\n\n    if (options.startAt !== null) {\n      if (Ember.typeOf(options.startAt) === 'object') {\n        reference = reference.startAt(options.startAt.value, options.startAt.key);\n      } else {\n        reference = reference.startAt(options.startAt);\n      }\n    }\n\n    if (options.endAt !== null) {\n      if (Ember.typeOf(options.endAt) === 'object') {\n        reference = reference.endAt(options.endAt.value, options.endAt.key);\n      } else {\n        reference = reference.endAt(options.endAt);\n      }\n    }\n\n    if (options.equalTo !== null) {\n      if (Ember.typeOf(options.equalTo) === 'object') {\n        reference = reference.equalTo(options.equalTo.value, options.equalTo.key);\n      } else {\n        reference = reference.equalTo(options.equalTo);\n      }\n    }\n\n    if (options.limit !== null) {\n      Ember.deprecate(\"limit is deprecated, use limitToFirst or limitToEnd instead\", false, {\n        id: 'fireplace.limit',\n        until: '1.0.0'\n      });\n      reference = reference.limit(options.limit);\n    }\n\n    if (options.limitToFirst !== null) {\n      reference = reference.limitToFirst(options.limitToFirst);\n    }\n\n    if (options.limitToLast !== null) {\n      reference = reference.limitToLast(options.limitToLast);\n    }\n\n    return reference;\n  },\n\n  save() {\n    return this.store.saveCollection(this);\n  },\n\n  modelClassFromSnapshot(snap) {\n    const modelName = get(this, 'model');\n    const baseClass = this.store.modelFor(modelName);\n    return baseClass.typeFromSnapshot(snap);\n  },\n\n  onFirebaseValue(snapshot) {\n    set(this, \"snapshot\", snapshot);\n  },\n\n  setupContent: Ember.on('init', function() {\n    if (!get(this, 'content')) {\n      set(this, 'content', Ember.A());\n    }\n  }),\n\n  insertAfter(prevItemName, item, collection) {\n    collection = collection || this;\n\n    let previous;\n    let previousIndex;\n\n    if (prevItemName) {\n      previous = collection.findBy('id', prevItemName);\n      if (previous) {\n        previousIndex = collection.indexOf(previous);\n        collection.insertAt(previousIndex + 1, item);\n      } else {\n        collection.pushObject(item);\n      }\n    } else {\n      collection.unshiftObject(item);\n    }\n  }\n\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/collections/indexed.js":"import Ember from 'ember';\nimport Collection from './base';\nimport MetaModel from '../model/meta-model';\nimport PromiseProxy from './promise';\n\nconst get = Ember.get;\nconst set = Ember.set;\n\nexport default Collection.extend({\n\n  firebaseEvents: \"child_changed\",\n\n  as: null, // the meta model wrapper to use\n\n  toFirebaseJSON() {\n    return this.reduce((json, item) => {\n      let value;\n      if (item instanceof MetaModel) {\n        value = item.toFirebaseJSON(true);\n      } else {\n        value = true;\n      }\n      json[get(item, 'id')] = value;\n      return json;\n    }, {});\n  },\n\n  // If we start listening straight after initializing then this is redundant\n  // as all the data gets sent in onFirebaseChildAdded anyway\n  // but we don't know if we're going to be live or not in the near future\n  // so inflate if we have a snapshot\n  inflateFromSnapshot: Ember.on(\"init\", function() {\n    const snapshot = get(this, \"snapshot\");\n    if (!snapshot) { return; }\n\n    const content = [];\n\n    // snapshot doesn't implement map\n    snapshot.forEach(child => {\n      content.push(this.itemFromSnapshot(child)); // avoid implicit return as Snapshot#forEach cancels if you return true\n    });\n\n    set(this, \"content\", Ember.A(content));\n  }),\n\n  contentChanged: Ember.on(\"init\", Ember.observer(\"content\", function() {\n    if (this._updatingContent) { return; }\n\n    const content = get(this, \"content\");\n    if (!content) { return; }\n\n    let anyTransformed = false;\n    const transformed = content.map(item => {\n      if (item instanceof Ember.Object) {\n        item = this.itemFromRecord(item);\n        anyTransformed = true;\n      }\n      return item;\n    });\n\n    if (anyTransformed) {\n      this._updatingContent = true;\n      set(this, \"content\", Ember.A(transformed));\n      this._updatingContent = false;\n    }\n  })),\n\n  // if we're listening, then our meta model items should be too\n  listenToFirebase() {\n    if (get(this, \"as\")) {\n      this.invoke(\"listenToFirebase\");\n    }\n    return this._super();\n  },\n\n  stopListeningToFirebase() {\n    if (get(this, \"as\")) {\n      this.invoke(\"stopListeningToFirebase\");\n    }\n    return this._super();\n  },\n\n  fetch() {\n    const promise = this.listenToFirebase().\n      then(this._fetchAll.bind(this)).\n      then(Ember.K.bind(this));\n\n    return PromiseProxy.create({promise: promise});\n  },\n\n  _fetchAll() {\n    return Ember.RSVP.all(get(this, \"content\").map((_, index) => this.objectAtContentAsPromise(index) ));\n  },\n\n  itemFromSnapshot(snapshot) {\n    return {\n      id:       snapshot.key(),\n      snapshot: snapshot,\n      record:   null\n    };\n  },\n\n  itemFromRecord(record) {\n    return {\n      id:       get(record, 'id'),\n      snapshot: null,\n      record:   this.wrapRecordInMetaObjectIfNeccessary(record)\n    };\n  },\n\n  replaceContent(start, numRemoved, objectsAdded) {\n    objectsAdded = objectsAdded.map(object => {\n      if (object instanceof MetaModel) {\n        object.set(\"parent\", this);\n        return this.itemFromRecord(object);\n      } else if (object instanceof Ember.Object) {\n        return this.itemFromRecord(object);\n      } else {\n        return object;\n      }\n    });\n    return this._super(start, numRemoved, objectsAdded);\n  },\n\n  objectAtContent(idx) {\n    const content = get(this, \"content\");\n    if (!content || !content.length) {\n      return;\n    }\n\n    const item = content.objectAt(idx);\n    if (!item) {\n      return;\n    }\n\n    // already inflated\n    if (item.record) {\n      return item.record;\n    }\n\n    item.record = this.findFetchRecordFromItem(item, false);\n\n    item.record.get(\"promise\").then(obj => {\n      if (item.record instanceof MetaModel) {\n        item.record.set(\"content\", obj);\n      } else {\n        item.record = obj;\n      }\n    });\n\n    return item.record;\n  },\n\n  objectAtContentAsPromise(idx) {\n    const content = get(this, \"content\");\n    if (!content || !content.length) {\n      return Ember.RSVP.reject();\n    }\n\n    const item = content.objectAt(idx);\n    if (!item) {\n      return Ember.RSVP.reject();\n    }\n\n    // already inflated\n    if (item.record) {\n      // is the item.record a promise proxy, if so return that\n      // so we end up with the actual object\n      const promise = item.record.get(\"promise\");\n      if (promise) {\n        return promise;\n      }\n      return Ember.RSVP.resolve(item.record);\n    }\n\n    const recordPromise = this.findFetchRecordFromItem(item, true);\n    return recordPromise.then(record => {\n      item.record = record;\n      return record;\n    });\n  },\n\n  // TODO - handle findOne failing (permissions / 404)\n  findFetchRecordFromItem(item, returnPromise) {\n    const store  = get(this, \"store\");\n    const query  = get(this, \"query\");\n    const type   = this.modelClassFromSnapshot(item.snapshot);\n\n    let record;\n    if (returnPromise) {\n      record = store.fetchOne(type, item.id, query);\n      return record.then(resolved => this.wrapRecordInMetaObjectIfNeccessary(resolved, item.snapshot) );\n    } else {\n      record = store.findOne(type, item.id, query);\n      return this.wrapRecordInMetaObjectIfNeccessary(record, item.snapshot);\n    }\n  },\n\n  wrapRecordInMetaObjectIfNeccessary(record, snapshot) {\n    const as = get(this, \"as\");\n    if (!as) {\n      return record;\n    }\n\n    if (record instanceof MetaModel) {\n      set(record, \"parent\", this);\n      return record;\n    }\n\n    const store    = get(this, \"store\");\n    const priority = snapshot ? snapshot.getPriority() : null;\n\n    const meta = store.buildRecord(as, null, {\n      content:  record,\n      priority: priority,\n      snapshot: snapshot,\n      parent:   this\n    });\n\n    if (snapshot) {\n      meta.listenToFirebase();\n    }\n    return meta;\n  },\n\n  onFirebaseChildAdded(snapshot, prevItemName) {\n    const id      = snapshot.key();\n    const content = get(this, \"content\");\n\n    if (content.findBy('id', id)) { return; }\n\n    const item = this.itemFromSnapshot(snapshot);\n    this.insertAfter(prevItemName, item, content);\n  },\n\n  onFirebaseChildRemoved(snapshot) {\n    const content = get(this, \"content\");\n    const item    = content.findBy('id', snapshot.key());\n\n    if (!item) { return; }\n\n    content.removeObject(item);\n  },\n\n  onFirebaseChildMoved(snapshot, prevItemName) {\n    const content = get(this, \"content\");\n    const item    = content.findBy('id', snapshot.key());\n\n    if (!item) { return; }\n\n    content.removeObject(item);\n\n    // only set priority on the meta-model, otherwise we'd nuke the priority\n    // on the underlying record which exists elsewhere in the tree and could have\n    // its own priority\n    if (get(this, \"as\") && item.record) {\n      set(item.record, 'priority', snapshot.getPriority());\n    }\n\n    this.insertAfter(prevItemName, item, content);\n  },\n\n  onFirebaseChildChanged(snapshot) {\n    const content = get(this, \"content\");\n    const item    = content.findBy('id', snapshot.key());\n\n    if (!item) { return; }\n\n    // if the type has changed, we need to fetch a new item\n    // otherwise we can just ignore this and assume the model itself is listening\n    const klass = this.modelClassFromSnapshot(snapshot);\n\n    let record = item.record;\n    if (record && this.get(\"as\")) {\n      record = record.get(\"content\");\n    }\n\n    if (record && record.constructor.typeKey === klass.typeKey) {\n      return;\n    }\n\n    // it's a polymorph whose type has changed, fetch a new item\n    const index   = content.indexOf(item);\n    const newItem = this.itemFromSnapshot(snapshot);\n\n    content.replace(index, 1, [newItem]);\n  }\n\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/collections/object.js":"import Ember from 'ember';\nimport Collection from './base';\nimport PromiseProxy from './promise';\n\nconst get = Ember.get;\nconst set = Ember.set;\n\n// TODO - there's no need for this to be an ArrayProxy, make Collection a mixin instead\n\nexport default Collection.extend({\n\n  toFirebaseJSON() {\n    return this.reduce((json, item) => {\n      json[get(item, 'id')] = item.toFirebaseJSON(true);\n      return json;\n    }, {});\n  },\n\n  // If we start listening straight after initializing then this is redundant\n  // as all the data gets sent in onFirebaseChildAdded anyway\n  // but we don't know if we're going to be live or not in the near future\n  // so inflate if we have a snapshot\n  inflateFromSnapshot: Ember.on(\"init\", function() {\n    const snapshot = get(this, \"snapshot\");\n    if (!snapshot) { return; }\n\n    // snapshot doesn't implement map\n\n    const content = [];\n    snapshot.forEach(child => {\n      content.push(this.modelFromSnapshot(child));  // avoid implicit return as Snapshot#forEach cancels if you return true\n    });\n\n    // The observer happens too late for the initial content\n    // so force it to setup right away\n    this.setupParentage(content);\n\n    set(this, \"content\", Ember.A(content));\n  }),\n\n  // if we're listening, then our existing children should be too\n  listenToFirebase() {\n    this.get(\"content\").invoke(\"listenToFirebase\");\n    return this._super();\n  },\n\n  stopListeningToFirebase() {\n    this.get(\"content\").invoke(\"stopListeningToFirebase\");\n    return this._super();\n  },\n\n  replaceContent(start, numRemoved, objectsAdded) {\n    this.setupParentage(objectsAdded);\n    return this._super(start, numRemoved, objectsAdded);\n  },\n\n  // when we have a value (which is when listenToFirebase resolves)\n  // then we know we have all our content because it all comes in\n  // the same result\n  fetch() {\n    const promise = this.listenToFirebase().then(Ember.K.bind(this));\n    return PromiseProxy.create({promise: promise});\n  },\n\n  contentChanged: Ember.on(\"init\", Ember.observer(\"content\", function() {\n    if (this.get(\"content\")) {\n      this.setupParentage(this.get(\"content\"));\n    }\n  })),\n\n  setupParentage(items) {\n    items.forEach((item) => {\n      item.setProperties({\n        parent:    this,\n        parentKey: null\n      });\n    });\n  },\n\n  modelFromSnapshot(snapshot) {\n    const modelName = this.modelClassFromSnapshot(snapshot);\n    const store     = get(this, 'store');\n    const query     = get(this, 'query') || {};\n\n    return store.findInCacheOrCreateRecord(modelName, snapshot.ref(), Ember.merge({\n      snapshot: snapshot,\n      priority: snapshot.getPriority()\n    }, query));\n  },\n\n  // TODO / OPTIMIZE - faster way of checking for existing inclusion instead of findBy(\"id\") each check\n  // on replaceContent we can build an ID map and then check that\n\n  onFirebaseChildAdded(snapshot, prevItemName) {\n    const id = snapshot.key();\n\n    if (this.findBy('id', id)) { return; }\n\n    const obj = this.modelFromSnapshot(snapshot);\n    this.insertAfter(prevItemName, obj);\n\n    // this needs to happen after insert, otherwise the parent isn't associated yet\n    // and the reference is incorrect\n    obj.listenToFirebase();\n  },\n\n  // TODO - should we destroy the item when removed?\n  // TODO - should the item be removed from the store's cache?\n  onFirebaseChildRemoved(snapshot) {\n    const item = this.findBy('id', snapshot.key());\n    if (!item) { return; }\n    this.removeObject(item);\n    item.stopListeningToFirebase();\n  },\n\n  onFirebaseChildMoved(snapshot, prevItemName) {\n    const item = this.findBy('id', snapshot.key());\n    if (!item) { return; }\n\n    this.removeObject(item);\n    set(item, 'priority', snapshot.getPriority());\n    this.insertAfter(prevItemName, item);\n  }\n\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/collections/promise.js":"import Ember from 'ember';\nexport default Ember.ArrayProxy.extend(Ember.PromiseProxyMixin);","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/model/attributes-mixin.js":"import Ember from 'ember';\n\nconst get        = Ember.get;\nconst underscore = Ember.String.underscore;\n\nexport const AttributesClassMixin = Ember.Mixin.create({\n  attributes: Ember.computed(function() {\n    const map = Ember.Map.create();\n\n    this.eachComputedProperty((name, meta) => {\n      if (meta.isAttribute) {\n        meta.name = name;\n        meta.key  = keyForAttribute(name, meta);\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  attributesByKey: Ember.computed(function(){\n    const map = Ember.Map.create();\n\n    this.eachComputedProperty((name, meta) => {\n      if (meta.isAttribute) {\n        meta.name = name;\n        meta.key  = keyForAttribute(name, meta);\n        map.set(meta.key, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  eachAttribute(callback, binding) {\n    get(this, 'attributes').forEach((meta, name) => {\n      callback.call(binding, name, meta);\n    });\n  },\n\n  attributeNameFromKey(key) {\n    const meta = get(this, 'attributesByKey').get(key);\n    return meta && meta.name;\n  },\n\n  attributeKeyFromName(name) {\n    const meta = get(this, 'attributes').get(name);\n    return meta && meta.key;\n  }\n});\n\nexport const AttributesMixin = Ember.Mixin.create({\n  eachAttribute(callback, binding) {\n    this.constructor.eachAttribute(callback, binding);\n  },\n\n  attributeNameFromKey(key) {\n    return this.constructor.attributeNameFromKey(key);\n  },\n\n  attributeKeyFromName(key) {\n    return this.constructor.attributeKeyFromName(key);\n  }\n});\n\nfunction keyForAttribute(name, meta) {\n  if (meta && meta.options.key) {\n    return meta.options.key;\n  } else {\n    return underscore(name);\n  }\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/model/attr.js":"import Ember from 'ember';\nimport {deserialize} from '../transforms/base';\nimport getOwner from 'ember-getowner-polyfill';\n\nconst get         = Ember.get;\nconst isNone      = Ember.isNone;\n\nexport default function(type, options) {\n  if (arguments.length === 1 && typeof type === \"object\") {\n    options = type;\n    type    = 'string';\n  }\n\n  options = options || {};\n\n  const meta = {\n    type:        type,\n    isAttribute: true,\n    options:     options\n  };\n\n  return Ember.computed({\n    get(name) {\n      const dataKey   = this.attributeKeyFromName(name);\n      const snapshot  = get(this, 'snapshot');\n\n      let value = snapshot.child(dataKey).val();\n\n      if (isNone(value)) {\n        value = getDefaultValue(this, options);\n      } else {\n\n        // default MODEL_FACTORY_INJECTIONS setting means the model doesn't have an owner\n        // we could set this to true, but that would break Ember Data should you be using both\n        // so get the store's owner instead and use that\n\n        const store     = get(this, \"store\");\n        const container = getOwner(store);\n\n        value = deserialize(this, value, meta, container);\n      }\n\n      return value;\n    },\n\n    set(name, value) {\n      if (isNone(value)) {\n        value = getDefaultValue(this, options);\n      }\n      return value;\n    }\n  }).meta(meta);\n}\n\nfunction getDefaultValue(obj, options) {\n  if (typeof options.default === 'function') {\n    return options.default.call(obj);\n  } else {\n    return options.default;\n  }\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/model/live-mixin.js":"import Ember from 'ember';\n\nconst get      = Ember.get;\nconst set      = Ember.set;\nconst classify = Ember.String.classify;\n\nexport default Ember.Mixin.create(Ember.Evented, {\n  isListeningToFirebase:  false,\n  concatenatedProperties: ['firebaseEvents'],\n  firebaseEvents:         ['value'], // always listen to value for listenToFirebase promise\n\n  buildFirebaseReference() {\n    Ember.assert(\"You must override buildFirebaseReference\");\n  },\n\n  // override to limit the reference by startAt/endAt/limit\n  // this is mainly for collections\n  buildFirebaseQuery() {\n    return this.buildFirebaseReference();\n  },\n\n  changeCameFromFirebase: Ember.computed(function() {\n    return !!this._settingFromFirebase;\n  }).volatile(),\n\n  settingFromFirebase(fn) {\n    this._settingFromFirebase = true;\n    fn.call(this);\n    this._settingFromFirebase = false;\n  },\n\n  willDestroy() {\n    this.stopListeningToFirebase();\n  },\n\n  listenToFirebase() {\n    if (this.isDestroying || this.isDestroyed) {\n      return Ember.RSVP.reject();\n    }\n\n    // prevent race condition where we're waiting for FB to respond\n    // and another listen call comes in\n    if (this._listenPromise) {\n      return this._listenPromise;\n    }\n\n    if (get(this, 'isListeningToFirebase')) {\n      return Ember.RSVP.resolve();\n    }\n\n    set(this, 'isListeningToFirebase', true);\n\n    this._fbEventHandlers = {};\n\n    // ensure value is listened to last, this doesn't matter for Firebase\n    // as child_added is called before value, but in MockFirebase it appears\n    // that the events are triggered in the order they are setup\n    const events = get(this, 'firebaseEvents').slice().reverse();\n\n    const ref = this.buildFirebaseQuery();\n\n    const promise = this._listenPromise = new Ember.RSVP.Promise((resolve, reject) => {\n      this.one(\"firebaseValue\",      resolve);\n      this.one(\"firebaseValueError\", reject);\n    }, \"FP: Value \"+ref.toString()).catch(e => {\n      set(this, 'isListeningToFirebase', false);\n      return Ember.RSVP.reject(e);\n    }).finally(() => {\n      this._listenPromise = null;\n    });\n\n    events.forEach(eventName => {\n      const handler    = this.buildHandler(eventName);\n      const errHandler = this.buildErrorHandler(eventName);\n\n      this._fbEventHandlers[eventName] = handler;\n      ref.on(eventName, handler, errHandler, this);\n    });\n\n    return promise;\n  },\n\n  buildErrorHandler(eventName) {\n    const triggerName = 'firebase' + classify(eventName) + \"Error\";\n    return e => this.trigger(triggerName, e);\n  },\n\n  buildHandler(eventName) {\n    const classyName  = classify(eventName);\n    const handlerName = 'onFirebase' + classyName;\n    const triggerName = 'firebase'   + classyName;\n    const store       = this.store;\n\n    return (...args) => {\n      store.enqueueEvent(() => {\n\n        // if the we have been destroyed since the event came in, then\n        // don't bother trying to update - destroying stops listening to firebase\n        // so we don't expect to receive any more updates anyway\n        if (this.isDestroying || this.isDestroyed) {\n          return;\n        }\n\n        this.trigger(triggerName, args);\n        this[handlerName].apply(this, args);\n      });\n    };\n  },\n\n  stopListeningToFirebase() {\n    this._listenPromise = null;\n\n    if (!get(this, 'isListeningToFirebase')) {\n      return;\n    }\n\n    set(this, 'isListeningToFirebase', false);\n\n    const ref = this.buildFirebaseQuery();\n\n    for (let eventName in this._fbEventHandlers) {\n      const handler = this._fbEventHandlers[eventName];\n      ref.off(eventName, handler, this);\n    }\n\n    this._fbEventHandlers = {};\n  }\n\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/model/meta-model.js":"import Ember from 'ember';\nimport {\n  ModelMixin,\n  ModelClassMixin\n} from './model-mixin';\n\nconst get    = Ember.get;\nconst isNone = Ember.isNone;\n\n\nconst MetaModel = Ember.ObjectProxy.extend(ModelMixin, {\n  id:        Ember.computed.alias('content.id'),\n  priority:  null,\n  parent:    null,\n  parentKey: null,\n\n  // meta is the simple value of the snapshot\n  // if attributes are defined then you can't also have a meta value\n  meta: Ember.computed(\"snapshot\", {\n    get() {\n      const attributes    = get(this.constructor, 'attributes');\n      const relationships = get(this.constructor, 'relationships');\n\n      if (attributes.size || relationships.size) {\n        return null;\n      }\n\n      return get(this, \"snapshot\").val();\n    },\n    set(key, value) {\n      const attributes    = get(this.constructor, 'attributes');\n      const relationships = get(this.constructor, 'relationships');\n\n      if (attributes.size || relationships.size) {\n        return null;\n      }\n\n      return value;\n    }\n  }),\n\n  buildFirebaseReference(){\n    const id        = get(this, 'id');\n    const parent    = get(this, 'parent');\n\n    Ember.assert(\"meta models must belong to a parent in order to generate a Firebase reference\", !!parent);\n\n    return parent.buildFirebaseReference().child(id);\n  },\n\n  toFirebaseJSON(includePriority) {\n    const attributes    = get(this.constructor, 'attributes');\n    const relationships = get(this.constructor, 'relationships');\n\n    if (attributes.size || relationships.size) {\n      const attrJSON = this._super(includePriority);\n\n      // if attributes are null, then we'll get an empty object back\n      // we don't want to save this as that'll be treated as deleting the meta model!\n      if (!Ember.$.isEmptyObject(attrJSON)) {\n        return attrJSON;\n      }\n    }\n\n    let meta = get(this, \"meta\");\n    if (isNone(meta)) {\n      meta = true;\n    }\n\n    if (includePriority) {\n      return this.wrapValueAndPriority(meta);\n    } else {\n      return meta;\n    }\n  },\n\n  saveContent() {\n    return this.get(\"content\").save();\n  },\n\n  changeCameFromFirebase: Ember.computed(function() {\n    return !!this._settingFromFirebase || get(this, \"content.changeCameFromFirebase\");\n  }).volatile()\n\n});\n\nexport default MetaModel;\n\nMetaModel.reopenClass(ModelClassMixin);\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/model/model.js":"import Ember from 'ember';\n\nimport expandPath from '../utils/expand-path';\nimport {\n  ModelMixin,\n  ModelClassMixin\n} from './model-mixin';\n\nconst get        = Ember.get;\nconst underscore = Ember.String.underscore;\nconst pluralize  = Ember.String.pluralize;\n\nconst Model = Ember.Object.extend(ModelMixin, {\n  id: Ember.computed({\n    get() {\n      const store = get(this, 'store');\n      return this.constructor.buildFirebaseRootReference(store).push().key();\n    },\n    set(key, value) {\n      return value;\n    }\n  }),\n\n  debugReference: Ember.computed(function(){\n    return this.buildFirebaseReference().toString();\n  }),\n\n  buildFirebaseReference(){\n    const id        = get(this, 'id');\n    const parent    = get(this, 'parent');\n    const parentKey = get(this, 'parentKey');\n\n    if (parent && parentKey) {\n      const childKey = parent.relationshipKeyFromName(parentKey);\n      return parent.buildFirebaseReference().child(childKey);\n    }\n\n    let ref;\n\n    if (parent) {\n      ref = parent.buildFirebaseReference();\n    } else {\n      const store = get(this, 'store');\n      ref = this.constructor.buildFirebaseReference(store, this);\n    }\n\n    return ref.child(id);\n  }\n});\n\nexport default Model;\n\nModel.reopenClass(ModelClassMixin, {\n  firebasePath(/* opts */) {\n    // typeKey is set in the store when looking up the factory\n    Ember.assert(\"No typeKey set, you must use the store to create/find records\", !!this.typeKey);\n    return pluralize(underscore(this.typeKey));\n  },\n\n  // override for polymophism\n  typeFromSnapshot(/* snapshot */) {\n    return this;\n  },\n\n  // defaults to the store's root reference, normally won't be overridden\n  // unless you have a different firebase per model, which could cause oddness!\n  buildFirebaseRootReference(store) {\n    return store.buildFirebaseRootReference();\n  },\n\n  // override if you want to do something different based on the options\n  // can be handy for polymorphism\n  firebasePathOptions(opts) {\n    return opts;\n  },\n\n  buildFirebaseReference(store, opts) {\n    opts = this.firebasePathOptions(opts || {});\n\n    let path = this.firebasePath;\n    if (typeof path === \"function\") {\n      // so firebase path can do opts.get(\"...\") regardless of being passed hash or model instance\n      if (!(opts instanceof Ember.Object)) {\n        opts = Ember.Object.create(opts);\n      }\n      path = path.call(this, opts);\n    }\n\n    if (typeof path === \"string\") {\n      path = expandPath(path, opts);\n    }\n\n    if (path instanceof window.Firebase) {\n      return path;\n    }\n\n    const root = this.buildFirebaseRootReference(store);\n    return root.child(path);\n  }\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/model/model-mixin.js":"import Ember from 'ember';\n\nimport getOwner from 'ember-getowner-polyfill';\n\nimport MutableSnapshot from '../support/mutable-snapshot';\nimport { serialize } from '../transforms/base';\nimport deepEqual from '../utils/deep-equal';\n\nimport LiveMixin from './live-mixin';\nimport {\n  AttributesClassMixin,\n  AttributesMixin\n} from './attributes-mixin';\nimport {\n  RelationshipsClassMixin,\n  RelationshipsMixin\n} from '../relationships/mixin';\n\nconst get       = Ember.get;\nconst set       = Ember.set;\nconst cacheFor  = Ember.cacheFor;\nconst isNone    = Ember.isNone;\n\nexport const ModelClassMixin = Ember.Mixin.create(AttributesClassMixin, RelationshipsClassMixin);\n\nexport const ModelMixin = Ember.Mixin.create(LiveMixin, AttributesMixin, RelationshipsMixin, Ember.Evented, {\n  firebaseEvents: ['child_added', 'child_removed', 'child_changed'],\n\n  store: null,\n\n  isNew: Ember.computed.not(\"_snapshot\"),\n\n  // the actual Firebase::Snapshot, can be null if new record\n  _snapshot: null,\n\n  // wrapped MutableSnapshot, will never be null\n  snapshot: Ember.computed(\"_snapshot\", {\n    get() {\n      const snapshot = get(this, \"_snapshot\");\n      return new MutableSnapshot(snapshot);\n    },\n    set(key, value) {\n      if (value instanceof MutableSnapshot) {\n        value = value.snapshot;\n      }\n      set(this, \"_snapshot\", value);\n      return new MutableSnapshot(value);\n    }\n  }),\n\n  willDestroy() {\n    const store = get(this, \"store\");\n    store.teardownRecord(this);\n\n    const parent = get(this, \"parent\");\n    const parentKey = get(this, \"parentKey\");\n\n    // TODO - remove this knowledge from here\n    // Ember data does this with registered collections etc...\n    if (parent && !parent.isDestroyed && !parent.isDestroying) {\n      if (parent && parentKey) {\n        set(parent, parentKey, null);\n      } else {\n        parent.removeObject(this);\n      }\n    }\n\n    this._super();\n  },\n\n  eachActiveRelation(cb) {\n    get(this.constructor, 'relationships').forEach((meta, name) => {\n      const item = cacheFor(this, name);\n      if (item) { cb(item); }\n    });\n  },\n\n  listenToFirebase() {\n    if (!get(this, 'isListeningToFirebase')) {\n      this.eachActiveRelation(item => item.listenToFirebase() );\n    }\n    return this._super();\n  },\n\n  stopListeningToFirebase() {\n    if (get(this, 'isListeningToFirebase')) {\n      this.eachActiveRelation(item => item.stopListeningToFirebase() );\n    }\n    return this._super();\n  },\n\n  setAttributeFromSnapshot(snapshot, valueRemoved) {\n    const key       = snapshot.key();\n    const attribute = this.attributeNameFromKey(key);\n    if (!attribute) { return; }\n\n    const current     = get(this, \"snapshot\");\n    const currentData = current.child(key).val();\n\n    let newVal;\n\n    // child_removed sends the old value back in the snapshot\n    if (valueRemoved) {\n      newVal   = null;\n      snapshot = null;\n    } else {\n      newVal = snapshot.val();\n    }\n\n    // don't bother triggering a property change if nothing has changed\n    // eg if we've got a snapshot & then started listening\n    // do deep comparison in-case this is a hash type\n    if (deepEqual(currentData, newVal)) {\n      return;\n    }\n\n    current.setChild(key, snapshot);\n\n    this.settingFromFirebase(() => this.notifyPropertyChange(attribute) );\n  },\n\n  notifyRelationshipOfChange(snapshot, valueRemoved) {\n    const key       = snapshot.key();\n    const attribute = this.relationshipNameFromKey(key);\n\n    if (!attribute) { return; }\n\n    // child_removed sends the old value back in the snapshot\n    if (valueRemoved) {\n      snapshot = null;\n    }\n\n    get(this, \"snapshot\").setChild(key, snapshot);\n\n    const meta = this.constructor.metaForProperty(attribute);\n    if (meta.kind === \"hasOne\") {\n      this.settingFromFirebase(() => this.notifyPropertyChange(attribute) );\n    }\n  },\n\n  onFirebaseChildAdded(snapshot) {\n    this.setAttributeFromSnapshot(snapshot);\n    this.notifyRelationshipOfChange(snapshot);\n  },\n\n  onFirebaseChildRemoved(snapshot) {\n    this.setAttributeFromSnapshot(snapshot, true);\n    this.notifyRelationshipOfChange(snapshot, true);\n  },\n\n  onFirebaseChildChanged(snapshot) {\n    this.setAttributeFromSnapshot(snapshot);\n    this.notifyRelationshipOfChange(snapshot);\n  },\n\n  onFirebaseValue(snapshot) {\n    // apparently we don't exist\n    if (snapshot && !snapshot.val()) {\n      this.destroy();\n    } else {\n      set(this, \"_snapshot\", snapshot);\n    }\n  },\n\n  update(key, value) {\n    set(this, key, value);\n    return this.save(key);\n  },\n\n  save(key) {\n    return get(this, 'store').saveRecord(this, key);\n  },\n\n  delete() {\n    return get(this, 'store').deleteRecord(this);\n  },\n\n  toFirebaseJSON(includePriority) {\n    const attributes    = get(this.constructor, 'attributes');\n    const relationships = get(this.constructor, 'relationships');\n    const snapshot      = get(this, \"_snapshot\");\n    const json          = {};\n\n    // default MODEL_FACTORY_INJECTIONS setting means the model doesn't have an owner\n    // we could set this to true, but that would break Ember Data should you be using both\n    // so get the store's owner instead and use that\n\n    const store     = get(this, \"store\");\n    const container = getOwner(store);\n\n    attributes.forEach((meta, name) => {\n      const value = get(this, name);\n      // Firebase doesn't like null values, so remove them\n      if (isNone(value)) { return; }\n\n      json[this.attributeKeyFromName(name)] = serialize(this, value, meta, container);\n    });\n\n    relationships.forEach((meta, name) => {\n      // we don't serialize detached relationships\n      if (meta.options.detached) { return; }\n\n      const key = this.relationshipKeyFromName(name);\n\n      // if we haven't loaded the relationship yet, get the data from the snapshot\n      // no point materializing something we already know the data of\n      const item = cacheFor(this, name);\n\n      let value;\n\n      if (item === undefined && snapshot) {\n        value = snapshot.child(key).exportVal();\n      } else if (isNone(item)) {\n        // Firebase doesn't like null values, so remove them\n        return;\n      } else {\n        // TODO - ideally we shouldn't have to know about these details here\n        // can we farm this off to a function on the relationship?\n        if (meta.kind === \"hasOne\") {\n          if (meta.options.embedded === false) {\n            value = get(item, \"id\");\n          } else if (meta.options.id) {\n            value = item.toFirebaseJSON(true);\n            value.id = get(item, \"id\");\n          } else {\n            value = item.toFirebaseJSON(true);\n          }\n        } else {\n          value = item.toFirebaseJSON(true);\n        }\n      }\n\n      json[key] = value;\n    });\n\n    return includePriority ? this.wrapValueAndPriority(json) : json;\n  },\n\n  wrapValueAndPriority(json) {\n    const priority = get(this, 'priority');\n    if (isNone(priority)) {\n      return json;\n    }\n\n    return {\n      '.value':    json,\n      '.priority': priority\n    };\n  }\n\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/model/promise-model.js":"import Ember from 'ember';\n\nconst set     = Ember.set;\nconst get     = Ember.get;\nconst resolve = Ember.RSVP.resolve;\n\n// reimplemented private method from Ember, but with setting\n// _settingFromFirebase so we can avoid extra saves down the line\n\nfunction observePromise(proxy, promise) {\n  promise.then(value => {\n    set(proxy, 'isFulfilled', true);\n    value._settingFromFirebase = true;\n    set(proxy, 'content', value);\n    value._settingFromFirebase = false;\n  }, reason => {\n    set(proxy, 'isRejected', true);\n    set(proxy, 'reason', reason);\n    // don't re-throw, as we are merely observing\n  });\n}\n\nexport default Ember.ObjectProxy.extend(Ember.PromiseProxyMixin, {\n\n  // forward on all content's functions where it makes sense to do so\n  _setupContentForwarding: Ember.on(\"init\", Ember.observer('content', function() {\n    const obj = get(this, \"content\");\n    if (!obj) { return; }\n\n    for (let prop in obj) {\n      if (!this[prop] && typeof obj[prop] === \"function\") {\n        this._forwardToContent(prop);\n      }\n    }\n  })),\n\n  _forwardToContent(prop) {\n    this[prop] = (...args) => {\n      const content = this.get(\"content\");\n      return content[prop].apply(content, args);\n    };\n  },\n\n  // re-implemented from Ember so we can call our own observePromise\n  promise: Ember.computed({\n    get() {\n      throw new Ember.Error(\"PromiseProxy's promise must be set\");\n    },\n    set(key, promise) {\n      promise = resolve(promise);\n      observePromise(this, promise);\n      return promise.then(); // fork the promise.\n    }\n  })\n\n});\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/relationships/has-many.js":"import Ember from 'ember';\nimport getOwner from 'ember-getowner-polyfill';\nimport expandPath from '../utils/expand-path';\nimport { extractQueryOptions } from '../utils/query';\n\n// options\n// embedded: (true)|false\n// detached: (false)|true\n// collection: custom collection type (or object|index depending...)\n// query: any additional data for non-embedded fetching\n// path: for detached relationships\n// as: for indexed associations\n// startAt/endAt/limit for filtering\n// key: (type)\n\nconst get    = Ember.get;\nconst isNone = Ember.isNone;\n\nexport default function(type, options) {\n  if (arguments.length === 1 && typeof type === \"object\") {\n    options = type;\n    type    = undefined;\n  }\n\n  options = options || {};\n\n  if (options.embedded === undefined) {\n    options.embedded = true;\n  }\n\n  const meta = {\n    type:           type,\n    isRelationship: true,\n    kind:           'hasMany',\n    options:        options\n  };\n\n  return Ember.computed({\n    get(key) {\n      const dataKey    = this.relationshipKeyFromName(key);\n      const snapshot   = get(this, \"snapshot\").child(dataKey).snapshot;\n      const collection = buildCollection(this, key, meta.type, options, { snapshot });\n\n      if (get(this, \"isListeningToFirebase\")) {\n        collection.listenToFirebase();\n      }\n      return collection;\n    },\n    set(key, content) {\n      if (isNone(content)) {\n        return null;\n      }\n\n      return buildCollection(this, key, meta.type, options, { content });\n    }\n  }).meta(meta);\n}\n\nfunction buildCollection(model, name, type, options, attrs) {\n  const store          = get(model, \"store\");\n  const container      = getOwner(store);\n  const collectionName = options.collection || (options.embedded ? \"object\" : \"indexed\");\n  const collectionType = container._lookupFactory(\"collection:\"+collectionName);\n\n  let query = options.query;\n\n  Ember.assert(\"Collection type must exist: \"+collectionName, !!collectionType);\n\n  if (typeof query === \"function\") {\n    query = query.call(model);\n  }\n\n  const collectionOpts = Ember.$.extend({}, attrs || {}, {\n    store:     store,\n    model:     type,\n    query:     query,\n    as:        options.as\n  }, extractQueryOptions(options));\n\n  if (options.detached) {\n    const modelClass = store.modelFor(type);\n\n    let reference;\n\n    if (options.path) {\n      let path = options.path;\n      if (typeof path === \"function\") {\n        path = path.call(model);\n      } else {\n        path = expandPath(path, model);\n      }\n      reference = modelClass.buildFirebaseRootReference(store).child(path);\n    } else {\n      reference = modelClass.buildFirebaseReference(store, query);\n    }\n\n    collectionOpts.firebaseReference = reference;\n  } else {\n    collectionOpts.parent    = model;\n    collectionOpts.parentKey = name;\n  }\n\n  return collectionType.create(collectionOpts);\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/relationships/has-one.js":"import Ember from 'ember';\n\n// options\n// embedded: (true)|false\n// detached: (false)|true\n// query: any additional data for non-embedded fetching\n// id:\n//     for detached queries, defaults to the object ID\n//     for embedded - include the ID in Firebase\n// key: (type)\n\nconst get    = Ember.get;\nconst isNone = Ember.isNone;\n\nexport default function(type, options) {\n  if (arguments.length === 1 && typeof type === \"object\") {\n    options = type;\n    type    = undefined;\n  }\n\n  options = options || {};\n\n  if (options.embedded === undefined && !options.detached) {\n    options.embedded = true;\n  }\n\n  Ember.assert(\"can't be both detached and embedded\", !options.detached || !options.embedded);\n\n  const meta = {\n    type:           type,\n    isRelationship: true,\n    kind:           'hasOne',\n    options:        options\n  };\n\n  return Ember.computed({\n    get(name) {\n      const store    = get(this, \"store\");\n      const snapshot = get(this, \"snapshot\");\n\n      let childSnap;\n\n      if (!options.detached) {\n        const dataKey = this.relationshipKeyFromName(name);\n        childSnap = snapshot.child(dataKey);\n        if (!childSnap.val()) { return null; }\n      }\n\n      if (options.embedded) {\n        const attributes = {\n          snapshot:  childSnap,\n          parent:    this,\n          parentKey: name\n        };\n\n        if (options.id) {\n          attributes.id = childSnap.child(\"id\").val();\n        }\n\n        const value = store.createRecord(meta.type, attributes);\n\n        if (get(this, \"isListeningToFirebase\")) {\n          value.listenToFirebase();\n        }\n\n        return value;\n      } else {\n        let itemID;\n        if (options.detached) {\n          itemID = options.id || get(this, \"id\");\n          if (typeof itemID === \"function\") {\n            itemID = itemID.call(this);\n          }\n        } else {\n          itemID = childSnap.val();\n          if (!itemID) { return null; }\n        }\n\n        let query = options.query;\n        if (typeof query === \"function\") {\n          query = query.call(this);\n        }\n        return store.findOne(meta.type, itemID, query);\n      }\n    },\n    set(name, value) {\n      if (isNone(value)) {\n        return null;\n      }\n\n      if (options.embedded) {\n        value.setProperties({\n          parent:    this,\n          parentKey: name\n        });\n      }\n\n      return value;\n    }\n  }).meta(meta);\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/relationships/mixin.js":"import Ember from 'ember';\n\nimport {\n  singularize\n} from 'ember-inflector';\n\nconst get         = Ember.get;\nconst underscore  = Ember.String.underscore;\n\nexport const RelationshipsClassMixin = Ember.Mixin.create({\n  relationships: Ember.computed(function() {\n    const map = Ember.Map.create();\n\n    this.eachComputedProperty((name, meta) => {\n      if (meta.isRelationship) {\n        meta.name = name;\n        meta.key  = keyForRelationship(name, meta);\n        meta.type = typeForRelationship(name, meta);\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  relationshipsByKey: Ember.computed(function() {\n    const map = Ember.Map.create();\n\n    this.eachComputedProperty((name, meta) => {\n      if (meta.isRelationship) {\n        meta.name = name;\n        meta.key  = keyForRelationship(name, meta);\n        meta.type = typeForRelationship(name, meta);\n        map.set(meta.key, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  relationshipNameFromKey(key) {\n    const meta = get(this, 'relationshipsByKey').get(key);\n    return meta && meta.name;\n  },\n\n  relationshipKeyFromName(name) {\n    const meta = get(this, 'relationships').get(name);\n    return meta && meta.key;\n  }\n});\n\nexport const RelationshipsMixin = Ember.Mixin.create({\n  relationshipNameFromKey(key) {\n    return this.constructor.relationshipNameFromKey(key);\n  },\n\n  relationshipKeyFromName(name) {\n    return this.constructor.relationshipKeyFromName(name);\n  }\n});\n\nfunction keyForRelationship(name, meta) {\n  if (meta && meta.options.key) {\n    return meta.options.key;\n  } else {\n    return underscore(name);\n  }\n}\n\nfunction typeForRelationship(name, meta) {\n  let type = meta.type;\n\n  if (!type && meta.kind === 'hasMany') {\n    type = singularize(name);\n  } else if (!type) {\n    type = name;\n  }\n\n  return type;\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/support/event-queue.js":"// handles running multiple firebase events in the same run-loop\n\nimport Ember from 'ember';\n\nconst EventQueue = function() {\n  this.pending = [];\n};\n\nexport default EventQueue;\n\nEventQueue.prototype = {\n  enqueue(fn, context) {\n    this.pending.push([fn, context]);\n\n    if (!this.running) {\n      this.running = true;\n      // TODO - running in the next runloop breaks the tests\n      // how to solve this without this hack?\n      const run = Ember.testing ? Ember.run : Ember.run.next;\n      run(this, this.flush);\n    }\n  },\n\n  flush() {\n    // if a batch queues items itself we want to make sure we run those too\n    // otherwise they'll be ignored\n    while (this.pending.length) {\n      let batch = this.pending;\n      this.pending = [];\n      this.runBatch(batch);\n    }\n\n    this.running = false;\n  },\n\n  runBatch(batch) {\n    batch.forEach(item => {\n      const fn      = item[0];\n      const context = item[1];\n      fn.call(context);\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/support/mutable-snapshot.js":"const MutableSnapshot = function(snapshot) {\n  this.snapshot = snapshot;\n  this.children = {};\n};\n\nexport default MutableSnapshot;\n\nMutableSnapshot.prototype.key = function() {\n  if (!this.snapshot) { return null; }\n  return this.snapshot.key();\n};\n\n// deprecated but keep it around until it's removed in Firebase\nMutableSnapshot.prototype.name = function() {\n  if (!this.snapshot) { return null; }\n  return this.snapshot.name();\n};\n\nMutableSnapshot.prototype.val = function() {\n  if (!this.snapshot) { return null; }\n  return this.snapshot.val();\n};\n\nMutableSnapshot.prototype.getPriority = function() {\n  if (!this.snapshot) { return null; }\n  return this.snapshot.getPriority();\n};\n\nMutableSnapshot.prototype.numChildren = function() {\n  if (!this.snapshot) { return 0; }\n  return this.snapshot.numChildren();\n};\n\nMutableSnapshot.prototype.ref = function() {\n  if (!this.snapshot) { return null; }\n  return this.snapshot.ref();\n};\n\nMutableSnapshot.prototype.setChild = function(key, snapshot) {\n  this.children[key] = snapshot;\n};\n\nMutableSnapshot.prototype.child = function(key) {\n  let childSnapshot;\n  if (this.children.hasOwnProperty(key)) {\n    childSnapshot = this.children[key];\n  } else if (this.snapshot) {\n    childSnapshot = this.snapshot.child(key);\n  }\n  return new MutableSnapshot(childSnapshot);\n};\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/system/debug-adapter.js":"import Ember from 'ember';\n\nimport Model from '../model/model';\n\nconst get        = Ember.get;\nconst capitalize = Ember.String.capitalize;\nconst underscore = Ember.String.underscore;\n\nexport default Ember.DataAdapter.extend({\n  getFilters() {\n    return [\n      { name: 'isLive',     desc: 'Live'    },\n      { name: 'isNew',      desc: 'New'     }\n    ];\n  },\n\n  detect(klass) {\n    return klass !== Model && Model.detect(klass);\n  },\n\n  columnsForType(type) {\n    const columns = [{ name: 'id', desc: 'Id' }];\n    let count = 0;\n\n    get(type, 'attributes').forEach((meta, name) => {\n        if (count++ > this.attributeLimit) { return false; }\n        const desc = capitalize(underscore(name).replace('_', ' '));\n        columns.push({ name: name, desc: desc });\n    });\n    columns.push({name: 'fbPath', desc: 'Firebase Path'});\n    return columns;\n  },\n\n  getRecords(type) {\n    return this.get('store').all(type);\n  },\n\n  recordReferenceToString(record) {\n    const ref  = record.buildFirebaseReference();\n    const root = ref.root().toString();\n\n    return ref.toString().slice(root.length);\n  },\n\n  getRecordColumnValues(record) {\n    let count = 0;\n\n    const columnValues = {\n      id: get(record, 'id'),\n      fbPath: this.recordReferenceToString(record)\n    };\n\n    record.eachAttribute(key => {\n      if (count++ > this.attributeLimit) {\n        return false;\n      }\n      const value = get(record, key);\n      columnValues[key] = value;\n    });\n\n    return columnValues;\n  },\n\n  getRecordKeywords(record) {\n    const keywords = Ember.A();\n    const keys = Ember.A(['id']);\n\n    record.eachAttribute(key => keys.push(key) );\n    keys.forEach(key => keywords.push(get(record, key)) );\n\n    return keywords;\n  },\n\n  getRecordFilterValues(record) {\n    return {\n      isLive:    record.get('isListeningToFirebase'),\n      isNew:     record.get('isNew')\n    };\n  },\n\n  getRecordColor(record) {\n    let color = 'black';\n    if (record.get('isListeningToFirebase')) {\n      color = 'green';\n    } else if (record.get('isNew')) {\n      color = 'blue';\n    }\n    return color;\n  },\n\n  observeRecord(record, recordUpdated) {\n    const releaseMethods = Ember.A();\n    const keysToObserve  = Ember.A(['id', 'isListeningToFirebase', 'isNew']);\n\n    record.eachAttribute(key => keysToObserve.push(key) );\n\n    keysToObserve.forEach(key => {\n      const handler = function() {\n        recordUpdated(this.wrapRecord(record));\n      };\n\n      Ember.addObserver(record, key, handler);\n\n      releaseMethods.push(() => {\n        Ember.removeObserver(record, key, handler);\n      });\n    });\n\n    return () => releaseMethods.forEach(fn => fn());\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/transforms/base.js":"import Ember from 'ember';\n\nexport default Ember.Object.extend({\n  serialize:   null,\n  deserialize: null\n});\n\nexport function deserialize(obj, value, meta, container) {\n  return transform(\"deserialize\", obj, value, meta, container);\n}\n\nexport function serialize(obj, value, meta, container) {\n  return transform(\"serialize\", obj, value, meta, container);\n}\n\nexport function transform(kind, obj, value, meta, container) {\n  const type      = meta.type;\n  const options   = meta.options;\n\n  if (options[kind]) {\n    return options[kind].call(obj, value);\n  }\n\n  if (!type) {\n    return value;\n  }\n\n  const transformer = container.lookup('transform:'+type);\n  if (!transformer) {\n    return value;\n  }\n\n  return transformer[kind](value, options);\n}\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/transforms/boolean.js":"import Transform from './base';\n\nexport default Transform.extend({\n  deserialize(serialized) {\n    return Boolean(serialized);\n  },\n\n  serialize(deserialized) {\n    return Boolean(deserialized);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/transforms/date.js":"import Transform from './base';\nimport dateParse from '../utils/date-parse';\n\nexport default Transform.extend({\n  deserialize(value) {\n    if (!value || typeof value !== \"string\") {\n      return null;\n    }\n    return new Date(dateParse(value));\n  },\n\n  serialize(value) {\n    if (!value || !value.toISOString) {\n      return null;\n    }\n    return value.toISOString();\n  }\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/transforms/hash.js":"import Transform from './base';\n\nexport default Transform.extend({\n  serialize(hash, options, container) {\n    return transformHash(\"serialize\", hash, options, container);\n  },\n\n  deserialize(hash, options, container) {\n    return transformHash(\"deserialize\", hash, options, container);\n  }\n});\n\nfunction transformHash(direction, hash, options, container) {\n  if (!hash) {\n    return null;\n  }\n\n  if (!options || !options.of) {\n    return hash;\n  }\n\n  const transform = container.lookup('transform:'+options.of);\n\n  const transformed = {};\n  for (let key in hash) {\n    transformed[key] = transform[direction](hash[key], options, container);\n  }\n  return transformed;\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/transforms/number.js":"import Ember from 'ember';\nimport Transform from './base';\n\nexport default Transform.extend({\n\n  deserialize(serialized) {\n    return Ember.isEmpty(serialized) ? null : Number(serialized);\n  },\n\n  serialize(deserialized) {\n    return Ember.isEmpty(deserialized) ? null : Number(deserialized);\n  }\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/transforms/string.js":"import Ember from 'ember';\nimport Transform from './base';\n\nexport default Transform.extend({\n  deserialize(serialized) {\n    return Ember.isNone(serialized) ? null : String(serialized);\n  },\n\n  serialize(deserialized) {\n    return Ember.isNone(deserialized) ? null : String(deserialized);\n  }\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/transforms/timestamp.js":"/* global Firebase */\n\nimport Transform from './base';\n\nexport function now() {\n  return Firebase.ServerValue.TIMESTAMP;\n}\n\nexport default Transform.extend({\n  deserialize(value) {\n    if (!value) {\n      return null;\n    }\n    return new Date(value);\n  },\n\n  serialize(value) {\n    if (value === Firebase.ServerValue.TIMESTAMP) {\n      return value;\n    }\n    if (!value || !value.getTime) {\n      return null;\n    }\n    return value.getTime();\n  }\n});","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/utils/date-parse.js":"/**\n  Based on Date.parse by Colin Snover <http://zetafleet.com>\n  https://github.com/csnover/js-iso8601\n*/\n\nconst origParse   = Date.parse;\nconst numericKeys = [ 1, 4, 5, 6, 7, 10, 11 ];\n\nexport default function (date) {\n    let timestamp, struct, minutesOffset = 0;\n\n    // ES5 15.9.4.2 states that the string should attempt to be parsed as a Date Time String Format string\n    // before falling back to any implementation-specific date parsing, so thats what we do, even if native\n    // implementations could be faster\n    //              1 YYYY                2 MM       3 DD           4 HH    5 mm       6 ss        7 msec        8 Z 9     10 tzHH    11 tzmm\n    if ((struct = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/.exec(date))) {\n        // avoid NaN timestamps caused by undefined values being passed to Date.UTC\n        for (let i = 0, k; (k = numericKeys[i]); ++i) {\n            struct[k] = +struct[k] || 0;\n        }\n\n        // allow undefined days and months\n        struct[2] = (+struct[2] || 1) - 1;\n        struct[3] = +struct[3] || 1;\n\n        if (struct[8] !== 'Z' && struct[9] !== undefined) {\n            minutesOffset = struct[10] * 60 + struct[11];\n\n            if (struct[9] === '+') {\n                minutesOffset = 0 - minutesOffset;\n            }\n        }\n\n        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);\n    }\n    else {\n        timestamp = origParse ? origParse(date) : NaN;\n    }\n\n    return timestamp;\n}\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/utils/deep-equal.js":"// naive deep equal\n\nexport default function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!a || !b) {\n    return false;\n  }\n\n  if (a && typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n\n  for (let prop in a) {\n    if (!deepEqual(a[prop], b[prop])) {\n      return false;\n    }\n  }\n\n  for (let prop in b) {\n    if (!a.hasOwnProperty(prop)) {\n      return false;\n    }\n  }\n\n  return true;\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/utils/expand-path.js":"import Ember from 'ember';\n\nconst get     = Ember.get;\nconst assert  = Ember.assert;\nconst inspect = Ember.inspect;\n\nexport default function(path, context) {\n  return path.replace(/{{([^}]+)}}/g, (match, key) => {\n    const value = get(context, key);\n    assert(\"Missing part for path expansion, looking for \"+key+\" in \"+inspect(context) + \" for \"+path, !!value);\n    return value;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/addon/utils/query.js":"import {\n  QUERY_OPTIONS\n} from '../collections/base';\n\nexport function extractQueryOptions(options) {\n  const query = {};\n  QUERY_OPTIONS.forEach(key => {\n    if (options.hasOwnProperty(key)) {\n      query[key] = options[key];\n    }\n  });\n  return query;\n}\n\nexport function hasQueryOptions(options) {\n  return QUERY_OPTIONS.filter(option => options.hasOwnProperty(option)).length > 0;\n}","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/collections/indexed.js":"import { IndexedCollection } from 'fireplace';\nexport default IndexedCollection;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/collections/object.js":"import { ObjectCollection } from 'fireplace';\nexport default ObjectCollection;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/data-adapters/main.js":"import Adapter from 'fireplace/system/debug-adapter';\n\nexport default Adapter;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/initializers/store.js":"export default {\n  name: 'fireplace:inject-store',\n\n  initialize(container, application) {\n    application.inject('controller',   'store', 'service:store');\n    application.inject('route',        'store', 'service:store');\n    application.inject('data-adapter', 'store', 'service:store');\n    application.inject('collection',   'store', 'service:store');\n    application.inject('component',    'store', 'service:store');\n  }\n};","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/services/store.js":"import Store from 'fireplace/store';\nexport default Store;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/transforms/boolean.js":"import Transform from 'fireplace/transforms/boolean';\nexport default Transform;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/transforms/date.js":"import Transform from 'fireplace/transforms/date';\nexport default Transform;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/transforms/hash.js":"import Transform from 'fireplace/transforms/hash';\nexport default Transform;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/transforms/number.js":"import Transform from 'fireplace/transforms/number';\nexport default Transform;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/transforms/string.js":"import Transform from 'fireplace/transforms/string';\nexport default Transform;","/home/travis/build/npmtest/node-npmtest-fireplace/node_modules/fireplace/app/transforms/timestamp.js":"import Transform from 'fireplace/transforms/timestamp';\nexport default Transform;"}